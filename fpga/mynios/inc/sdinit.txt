
uint8_t Sd2Card_cardinit() {
  Sd2Card_type_ = 0;
  // 16-bit init start time allows over a minute
  uint32_t arg;

  // set pin modes
  SPI_CHIP_SELECT_INIT();
  SPI_CHIP_SELECT_HIGH();
  SPI_MISO_INIT();
  SPI_MOSI_INIT();
  SPI_SCK_INIT();


  // must supply min of 74 clock cycles with CS high.
  for (uint8_t i = 0; i < 10; i++) spiSend(0XFF);

  SPI_CHIP_SELECT_LOW();

  // command to go idle in SPI mode
  uint8_t ok = 0;
  for(uint32_t i=0;i<100;i++){//SD_INIT_TIMEOUT*1000
    if((Sd2Card_status_ = Sd2Card_cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
    }
    else
    {
      ok=1;
      break;
    }
  }
  if (!ok) {
    errCode = 1;
    goto fail;
  }

  // check SD version
  if ((Sd2Card_cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    Sd2Card_type_ = SD_CARD_TYPE_SD1;
  } else {
    // only need last byte of r7 response
    for (uint8_t i = 0; i < 4; i++) Sd2Card_status_ = spiRec();
    if (Sd2Card_status_ != 0XAA) {
      errCode = 2;
      goto fail;
    }
    Sd2Card_type_ = SD_CARD_TYPE_SD2;
  }
  // initialize card and send host supports SDHC if SD2
  arg = Sd2Card_type_ == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;

  ok=0;
  for(uint32_t i=0;i<100;i++){//SD_INIT_TIMEOUT*1000
    Sd2Card_cardCommand(CMD55, 0);
    if((Sd2Card_status_ = Sd2Card_cardCommand(ACMD41, arg)) != R1_READY_STATE) {
    }
    else
    {
      ok=1;
      break;
    }
  }
  if (!ok) {
      errCode = 3;
      goto fail;
  }
  
  // if SD2 read OCR register to check for SDHC card
  if (Sd2Card_type_ == SD_CARD_TYPE_SD2) {
    if (Sd2Card_cardCommand(CMD58, 0)) {
      errCode = 5;
      goto fail;
    }
    if ((spiRec() & 0XC0) == 0XC0) Sd2Card_type_ = SD_CARD_TYPE_SDHC;
    // discard rest of ocr - contains allowed voltage range
    for (uint8_t i = 0; i < 3; i++) spiRec();
  }
  SPI_CHIP_SELECT_HIGH();

  return true;

 fail:
  SPI_CHIP_SELECT_HIGH();
  return false;
}
