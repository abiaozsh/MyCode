
void rnd(){
asm("clc");
asm("lda _rand0");//SEED *= $01010101
asm("adc _rand1");
asm("sta _rand1");
asm("adc _rand2");
asm("sta _rand2");
asm("adc _rand3");
asm("sta _rand3");
asm("clc       ");
asm("lda _rand0");//SEED += $31415927
asm("adc #$27  ");
asm("sta _rand0");
asm("lda _rand1");
asm("adc #$59  ");
asm("sta _rand1");
asm("pha       ");
asm("lda _rand2");
asm("adc #$41  ");
asm("sta _rand2");
asm("and #$7f  ");//Suppress sign bit (make it positive)
asm("tax       ");
asm("lda _rand3");
asm("adc #$31  ");
asm("sta _rand3");
asm("pla       ");//return bit 8-22 in (X,A)
}

void __fastcall__ waitvblank (void)
{
    if(((*(char*)(0x2002))&128)!=0)
    {
        while(((*(char*)(0x2002))&128)!=0)
        {
        }
        while(((*(char*)(0x2002))&128)==0)
        {
        }
    }
    else
    {
        while(((*(char*)(0x2002))&128)==0)
        {
        }
    }
}

void nmi()
{

}

#define presskey(key,k) (key & (k))
#define button_A        0x80
#define button_B        0x40
#define button_SELECT    0x20
#define button_START    0x10
#define button_UP        0x08
#define button_DOWN        0x04
#define button_LEFT        0x02
#define button_RIGHT    0x01

char const data[512] = {
// 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
//0
0x07,0x00,0x03,0x00,0x03,0x00,0x06,0x00,0x11,0x11,0x04,0x00,0x00,0x00,0x00,0x00, //0
0x25,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x01,0x00,0x00,0x00,0x01,0x01, //1
0x07,0x00,0x03,0x00,0x03,0x00,0x06,0x00,0x11,0x11,0x04,0x00,0x00,0x00,0x05,0x04, //2
0x25,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x01,0x00,0x00,0x00,0x03,0x03, //3
0x9B,0x00,0xA8,0x00,0x00,0x00,0x00,0x00,0x22,0x00,0x02,0x00,0x00,0x00,0x01,0x04, //4
0x9B,0x00,0xA8,0x00,0x00,0x00,0x00,0x00,0x22,0x00,0x02,0x00,0x00,0x00,0x05,0x01, //5
0x9B,0x00,0xA8,0x00,0x00,0x00,0x00,0x00,0x22,0x00,0x02,0x00,0x00,0x00,0x06,0x06, //6
0x9B,0x00,0xA8,0x00,0x00,0x00,0x00,0x00,0x22,0x00,0x02,0x00,0x00,0x00,0x07,0x07, //7
0x70,0x00,0xAB,0x00,0x06,0x00,0x00,0x00,0x22,0x01,0x03,0x00,0x00,0x00,0x08,0x06, //8
0x95,0x00,0x80,0x04,0x00,0x00,0x00,0x00,0x32,0x00,0x02,0x00,0x00,0x00,0x07,0x09, //9
0x70,0x00,0xAB,0x00,0x06,0x00,0x00,0x00,0x22,0x01,0x03,0x00,0x00,0x00,0x06,0x0A, //A
0x95,0x00,0x80,0x04,0x00,0x00,0x00,0x00,0x32,0x00,0x02,0x00,0x00,0x00,0x0B,0x07, //B
0x07,0x00,0x98,0x00,0x60,0x00,0x00,0x00,0x21,0x02,0x03,0x00,0x00,0x00,0x03,0x0C, //C
0xB0,0x04,0xA5,0x00,0x00,0x00,0x00,0x00,0x23,0x00,0x02,0x00,0x00,0x00,0x0B,0x09, //D
0x07,0x00,0x98,0x00,0x60,0x00,0x00,0x00,0x21,0x02,0x03,0x00,0x00,0x00,0x0E,0x03, //E
0xB0,0x04,0xA5,0x00,0x00,0x00,0x00,0x00,0x23,0x00,0x02,0x00,0x00,0x00,0x08,0x0A, //F
0x07,0x00,0x03,0x00,0x48,0x00,0x00,0x00,0x11,0x02,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x07,0x25,0x0A,0x00,0x00,0x00,0x00,0x33,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
0x95,0x00,0x30,0x00,0x60,0x00,0x00,0x00,0x22,0x02,0x03,0x00,0x00,0x00,0x00,0x00,
0x2B,0x04,0x06,0x00,0x00,0x00,0x00,0x00,0x13,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
0x4B,0x00,0x03,0x00,0x06,0x00,0x00,0x00,0x12,0x01,0x03,0x00,0x00,0x00,0x00,0x00,
0x07,0x00,0x28,0x04,0x00,0x00,0x00,0x00,0x31,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
0x70,0x00,0x30,0x00,0xA5,0x00,0x00,0x00,0x22,0x02,0x03,0x00,0x00,0x00,0x00,0x00,
0x25,0x09,0x00,0x06,0x00,0x00,0x00,0x00,0x33,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
0x70,0x00,0xF5,0x04,0x00,0x00,0x00,0x00,0x32,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
0x70,0x00,0xC5,0x00,0x60,0x00,0x00,0x00,0x22,0x02,0x03,0x00,0x00,0x00,0x00,0x00,
0xD5,0x04,0x60,0x00,0x00,0x00,0x00,0x00,0x23,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
0x07,0x00,0x4E,0x00,0x06,0x00,0x00,0x00,0x21,0x01,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x11,0x11,0x11,0x11,0x11,0x11,//<<rnd
0x11,0x11,0x12,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x23,0x33,0x33,0x33,0x33,//<<rnd
0x33,0x33,0x33,0x33,0x33,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x55,0x55,//<<rnd
0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66 //<<rnd
};
char const img[512] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//0
0xFF,0xFF,0xC3,0xC3,0xC3,0xC3,0xFF,0xFF,0x01,0x03,0x3F,0x3F,0x3F,0x3F,0x7F,0xFF,//1
0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,//2
0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//3
0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xFF,0xFF,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x7F,0xFF,//4
0xFF,0xFF,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0x01,0x03,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,//5
0xFF,0xFF,0x03,0x03,0x03,0x03,0xFF,0xFF,0x01,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//6
0xFF,0xFF,0xC0,0xC0,0xC0,0xC0,0xFF,0xFF,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x7F,0xFF,//7
0xFF,0xFF,0x03,0x03,0x03,0x03,0xC3,0xC3,0x01,0x03,0xFF,0xFF,0xFF,0xFF,0xBF,0x3F,//8
0xC3,0xC3,0xC0,0xC0,0xC0,0xC0,0xFF,0xFF,0x3E,0x3C,0x3F,0x3F,0x3F,0x3F,0x7F,0xFF,//9
0xC3,0xC3,0x03,0x03,0x03,0x03,0xFF,0xFF,0x3F,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//10
0xFF,0xFF,0xC0,0xC0,0xC0,0xC0,0xC3,0xC3,0x00,0x00,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,//11
0xC3,0xC3,0x00,0x00,0x00,0x00,0xFF,0xFF,0x3E,0x3C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//12
0xC3,0xC3,0xC0,0xC0,0xC0,0xC0,0xC3,0xC3,0x3E,0x3C,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,//13
0xFF,0xFF,0x00,0x00,0x00,0x00,0xC3,0xC3,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xBF,0x3F,//14
0xC3,0xC3,0x03,0x03,0x03,0x03,0xC3,0xC3,0x3F,0x3F,0xFF,0xFF,0xFF,0xFF,0xBF,0x3F,//15
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,//0 MM
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x38,0x24,0x24,0x38,0x20,0x20,0x20,0x20,//1 P
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x38,//2 U
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3C,0x40,0x40,0x38,0x04,0x04,0x04,0x78,//3 S
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x44,0x44,0x44,0x7C,0x44,0x44,0x44,0x44,//4 H
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x10,0x28,0x44,0x7C,0x44,0x44,0x44,0x44,//5 A
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x44,0x48,0x50,0x60,0x50,0x48,0x44,0x44,//6 K
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x7C,//7 E
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x44,0x28,0x28,0x10,0x10,0x10,0x10,0x10,//8 Y
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//9
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//A
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//B
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//C
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//D
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//E
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 //F
};

char Board[100];
char DrawBuff[16];//sp*4 //10*data+address

int PosX;
int PosY;
int NextShapeNo;
int NowShapeNo;
int NowDirectionNo;

char getNowBlock(int i,int j){
    int idx = (NowShapeNo<<6)+(NowDirectionNo<<4)+(i<<1)+(j>>1);
    if((j&1)==0)
    {
        return data[idx]&0x0F;
    }
    else
    {
        return (data[idx]>>4)&0x0F;
    }
}
char getNextBlock(int i,int j){
    int idx = (NextShapeNo<<6)+(i<<1)+(j>>1);
    if((j&1)==0)
    {
        return data[idx]&0x0F;
    }
    else
    {
        return (data[idx]>>4)&0x0F;
    }
}
char getNowBottom(int i){
    int idx = (NowShapeNo<<6)+(NowDirectionNo<<4)+8+(i>>1);
    if((i&1)==0)
    {
        return data[idx]&0x0F;
    }
    else
    {
        return (data[idx]>>4)&0x0F;
    }
}
char getNowLeft(){
    int idx = (NowShapeNo<<6)+(NowDirectionNo<<4)+10;
    return data[idx];
}

//x:0~9 y:0~19
void setBoard(int x,int y,int val){
    int base=(y<<2)+y;//x*5
    base=base+(x>>1);
    if((x & 0x01)==0)
        Board[base] = (Board[base] & 0xF0) | val;//low 4
    else
        Board[base] = (Board[base] & 0x0F) | (val<<4);//high 4
}
char getBoard(int x,int y){
    int base=(y<<2)+y;//x*5
    base=base+(x>>1);
    if((x & 0x01)==0)
        return Board[base] & 0x0F;//low 4
    else
        return Board[base] >> 4;//high 4
}
int getRnd7(){
    int r;
    char v;
    r = rand();
    v = data[0x01C0+(r&0x3F)];
    if((r&0x40)==0)
    {
        return v&0x0F;
    }
    else
    {
        return (v>>4)&0x0F;
    }
    //return Math.floor(Math.random()*7);
}

void DrawNextShape(){
    int i,j,idx=0;
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            int x,y;
            char block;
            x = 12+i;
            y = 2+j;
            block = getNextBlock(i,j);
            if(block!=0)
            {
                DrawBuff[idx++]=((y+3)<<3)-1;
                DrawBuff[idx++]=block;
                DrawBuff[idx++]=0;
                DrawBuff[idx++]=(x+2)<<3;
            }
        }
    }
    waitvblank();
    *(char*)(0x2003)=16; //i<<2
    for(i=0;i<16;i++)
    {
        *(char*)(0x2004)=DrawBuff[i];
    }
}

//core
void Clear(){
    int i,j;
    for(i=0;i<10;i++)
    {
        for(j=0;j<20;j++)
        {
            setBoard(i,j,0);
        }
    }
}
void NextShape(){
    NowShapeNo = NextShapeNo;
    NowDirectionNo = 0;
    PosY = 19;
    PosX = 3;
    NextShapeNo = getRnd7();
    DrawNextShape();
}
int Touch(){
    int i;
    for(i=0;i<4;i++)
    {
        char bottom = getNowBottom(i);
        if(bottom!=0)
        {
            if(bottom==PosY+1)
            {
                return 1;
            }
            if(getBoard(PosX+i,PosY-bottom)!=0)
            {
                return 1;
            }
        }
    }
    return 0;
}


void setvram(int a,char v){
    *(char*)(0x2006)=a>>8;
    *(char*)(0x2006)=a & 0x00FF;
    *(char*)(0x2007)=v;
}

void setppu(){
    *(char*)(0x2000) = 0x80; //10 00 00 00
    *(char*)(0x2001) = 0x18; //00 01 10 00

    *(char*)(0x2005) = 0;
    *(char*)(0x2005) = 0;
}
void desetppu(){
    *(char*)(0x2000) = 0x00; //00 00 00 00
    *(char*)(0x2001) = 0x00; //00 00 00 00

    *(char*)(0x2005) = 0;
    *(char*)(0x2005) = 0;
}

void setTile(int x,int y,char value){
    int base = 0x2020;
    base+=y<<5;
    base+=x;
    setvram(base,value);
}

void setTile2(char value){
    *(char*)(0x2007)=value;
}

void DrawShape(){
    int i,j,idx=0;
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            int x,y;
            char block;
            x = i+PosX;
            y = j+19-PosY;
            block = getNowBlock(i,j);
            if(block!=0)
            {
                DrawBuff[idx++]=((y+3)<<3)-1;
                DrawBuff[idx++]=block;
                DrawBuff[idx++]=0;
                DrawBuff[idx++]=(x+2)<<3;
            }
        }
    }
    waitvblank();
    *(char*)(0x2003)=0; //i<<2
    for(i=0;i<16;i++)
    {
        *(char*)(0x2004)=DrawBuff[i];
    }
}

void TouchDo(){
    int i,j,idx=0;
    //add to board
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            int x=PosX+i;
            int y=PosY-j;
            char block = getNowBlock(i,j);
            if(block!=0)
            {
                setBoard(x,y,block);
                {
                    int base = 0x2020;
                    base+=(19-y+2)<<5;
                    base+=(x+2);
                    DrawBuff[idx++]=base>>8;
                    DrawBuff[idx++]=base & 0x00FF;
                    DrawBuff[idx++]=block;
                }
            }
        }
    }
    idx=0;
    waitvblank();
    for(i=0;i<4;i++)
    {
        *(char*)(0x2006)=DrawBuff[idx++];
        *(char*)(0x2006)=DrawBuff[idx++];
        *(char*)(0x2007)=DrawBuff[idx++];
    }
    *(char*)(0x2005) = 0;
    *(char*)(0x2005) = 0;
    //setTile(0,0,0x10);

    
    
    
    //clear line
    for(j=19;j>=0;j--)
    {
        char line=1;
        for(i=0;i<10;i++)
        {
            if(getBoard(i,j)==0)
            {
                line=0;
                break;
            }
        }
        if(line==1)
        {
            int k,l;
            for(k=0;k<10;k++)
            {
                if(j-1>=0)
                {
                    setBoard(k,j-1,data[(getBoard(k,j-1)<<4)+0x0E]);
                }
                if(j+1<20)
                {
                    setBoard(k,j+1,data[(getBoard(k,j+1)<<4)+0x0F]);
                }
                setBoard(k,j,0);
            }
            
            if(j-1>=0)
            {
                int base = 0x2020;
                base+=(19-(j-1)+2)<<5;
                base+=(0+2);
                DrawBuff[0]=base>>8;
                DrawBuff[1]=base&0x00FF;
                for(l=0;l<10;l++)
                {
                    DrawBuff[2+l]=getBoard(l,j-1);
                }
                waitvblank();
                *(char*)(0x2006)=DrawBuff[0];
                *(char*)(0x2006)=DrawBuff[1];
                for(i=2;i<12;i++)
                {
                    *(char*)(0x2007)=DrawBuff[i];
                }
                *(char*)(0x2005) = 0;
                *(char*)(0x2005) = 0;
                //setTile(0,0,0x10);
            }
            for(k=j;k<19;k++)
            {
                for(l=0;l<10;l++)
                {
                    setBoard(l,k,getBoard(l,k+1));
                }
                {
                    int base = 0x2020;
                    base+=(19-k+2)<<5;
                    base+=(0+2);
                    DrawBuff[0]=base>>8;
                    DrawBuff[1]=base&0x00FF;
                    for(l=0;l<10;l++)
                    {
                        DrawBuff[2+l]=getBoard(l,k);
                    }
                    waitvblank();
                    *(char*)(0x2006)=DrawBuff[0];
                    *(char*)(0x2006)=DrawBuff[1];
                    for(i=2;i<12;i++)
                    {
                        *(char*)(0x2007)=DrawBuff[i];
                    }
                    *(char*)(0x2005) = 0;
                    *(char*)(0x2005) = 0;
                    //setTile(0,0,0x10);
                }
            }
        }
        
    }
    
    //is gameover
    for(i=0;i<10;i++)
    {
        if(getBoard(i,18)!=0)
        {
            Clear();
            {
                for(i=0;i<10;i++)
                {
                    for(j=0;j<20;j++)
                    {
                        setTile(2+i,2+j,0);
                    }
                }
            }
            break;
        }
    }
    NextShape();
    //draw shape
    DrawShape();
    //TODO DRAW Next
}

int Any_Touch(){
    int i,j;
    if(PosX<0)
    {
        return 1;
    }
    if(getNowLeft()+PosX>10)
    {
        return 1;
    }
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            int x=PosX+i;
            int y=PosY-j;
            int bottom = getNowBottom(i);
            if(PosY-bottom<-1)
            {
                return 1;
            }
            if(x>=0&&y>=0&&x<10&&y<20&&getNowBlock(i,j)!=0&&getBoard(x,y)!=0)
            {
                return 1;
            }
        }
    }
    return 0;
}
void rotate(int n){
    int left;
    NowDirectionNo=(NowDirectionNo+4+n)&3;
    left = getNowLeft();
    if(left+PosX>10)
    {
        PosX=10-left;
    }
    if(Any_Touch())
    {
        NowDirectionNo=(NowDirectionNo+4-n)&3;
    }
    DrawShape();
}
void movelr(int n){
    PosX+=n;
    if(Any_Touch()==1)
    {
        PosX-=n;
    }
    DrawShape();
}
void down(){
    while(Touch()!=1)
    {
        PosY--;
    }
    TouchDo();
}

void slowdown(){
    if(Touch()==1)
    {
        TouchDo();
    }
    else
    {
        PosY--;
        DrawShape();
    }
}

char read_joystick_1(){
       char n=8,joy_state=0;
       *(char*)(0x4016)=01;
       *(char*)(0x4016)=00;
       while(n){
            joy_state=(joy_state<<1)|*(char*)(0x4016)&1;
            --n;
       }
       return joy_state;
}

void dummy()
{
asm ("lda     _PosX");
asm ("ldx     _PosX+1");
asm ("sta     regsave");
asm ("stx     regsave+1");
asm ("jsr     incax1");
asm ("sta     _PosX");
asm ("stx     _PosX+1");
asm ("lda     regsave");
asm ("ldx     regsave+1");
}

void main()
{
    int i,j;
    
    int x=10,y=10;
    char n=5;
    
    int cnt = 0;
    int cnt2 = 0;
    char lastkey;

    dummy();
    
    //init pattern
    for(i=0;i<512;i++)
    {
        setvram(0x0000+i,img[i]);
    }

    *(char*)(0x2003)=0; //i<<2
    for(i=0;i<64;i++)
    {
        *(char*)(0x2004)=-1;
        *(char*)(0x2004)=0;
        *(char*)(0x2004)=0;
        *(char*)(0x2004)=-1;
    }

    //set background black
    for(i=0;i<32;i++)
    {
        for(j=0;j<28;j++)
        {
            setTile(i,j,0x10);
        }
    }
    
    //set color
    setvram(0x3F00,0x2C);
    
    setvram(0x3F01,0x30);
    setvram(0x3F02,0x00);
    setvram(0x3F03,0x3F);
    
    setvram(0x3F11,0x30);
    setvram(0x3F12,0x22);
    setvram(0x3F13,0x3F);
    
    //show init title
    setTile(5,5,0x11);
    setTile(6,5,0x12);
    setTile(7,5,0x13);
    setTile(8,5,0x14);
    setTile(9,5,0x10);
    setTile(10,5,0x15);
    setTile(11,5,0x10);
    setTile(12,5,0x16);
    setTile(13,5,0x17);
    setTile(14,5,0x18);

    //endframe reset
    setTile(0,0,0x10);*(char*)(0x2005) = 0;*(char*)(0x2005) = 0;

    //init ppu
    setppu();

    //wait for key pressed
    while(1)
    {
        char key;
        getRnd7();
        key = read_joystick_1();
        if(key!=0)break;
    }
    
    desetppu();

    Clear();

    for(i=0;i<10;i++)
    {
        for(j=0;j<20;j++)
        {
            setTile(2+i,2+j,0);
        }
    }
    
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            setTile(14+i,4+j,0);
        }
    }
    setppu();

    NextShape();
    NextShape();

    while(1)
    {
        char keytmp;
        char key;
        waitvblank();
        
        //one second count
        if(cnt++==50)
        {
            cnt=0;
            slowdown();
        }
        
        keytmp = read_joystick_1();
        key = (keytmp ^ lastkey) & keytmp;
        if(key!=0)
        {
            if(presskey(keytmp,button_UP))slowdown();
            if(presskey(key,button_DOWN))down();
            if(presskey(keytmp,button_LEFT))movelr(-1);
            if(presskey(keytmp,button_RIGHT))movelr(1);
            if(presskey(key,button_A))rotate(1);
            if(presskey(key,button_B))rotate(-1);
            
            /*
            if(presskey(button_UP))y--;
            if(presskey(button_DOWN))y++;
            if(presskey(button_LEFT))x--;
            if(presskey(button_RIGHT))x++;
            if(presskey(button_A))n++;
            if(presskey(button_B))n--;
            */
/*        
            waitvblank();
            *(char*)(0x2003)=0; //i<<2
            *(char*)(0x2004)=y;
            *(char*)(0x2004)=n;
            *(char*)(0x2004)= 0  ;//vhp000cc  001
            //*(char*)(0x2004)= 0  ;//vhp000cc  001
            *(char*)(0x2004)=x;
            
            //setTile(0,0,0x10);*(char*)(0x2005) = 0;*(char*)(0x2005) = 0;

    
对vhp000cc的解释：
第7位（v）为垂直翻滚控制、
第6位（h）为水平翻滚控制、
第5位（p）为优先权控制（浮于背景前还是背景后）、
第2-4位为空、
第0-1位为精灵调色板号选择。
*/



        }
        lastkey = keytmp;
    }
}


/*


;
; Randum number generator
;
; Written and donated by Sidney Cadot - sidney@ch.twi.tudelft.nl
;
; May be distributed with the cc65 runtime using the same license.
;
;
; int rand (void);
; void srand (unsigned seed);
;
;  Uses 4-byte state.
;  Multiplier must be 1 (mod 4)
;  Added value must be 1 (mod 2)
;  This guarantees max. period (2**32)
;  Bits 8-22 are returned (positive 2-byte int)
;  where 0 is LSB, 31 is MSB.
;  This is better as lower bits exhibit easily
;  detectable patterns.
;

          .export        _rand, _srand

.data

; The seed. When srand() is not called, the C standard says that that rand()
; should behave as if srand() was called with an argument of 1 before.
rand:      .dword   1

.code

_rand:    clc
    lda    rand+0        ; SEED *= $01010101
    adc     rand+1
    sta     rand+1
    adc     rand+2
    sta     rand+2
    adc     rand+3
    sta     rand+3
    clc
    lda     rand+0        ; SEED += $31415927
    adc     #$27
    sta     rand+0
    lda     rand+1
    adc     #$59
    sta     rand+1
    pha
     lda     rand+2
    adc     #$41
    sta     rand+2
    and     #$7f        ; Suppress sign bit (make it positive)
    tax
     lda     rand+3
    adc     #$31
    sta     rand+3
    pla             ; return bit 8-22 in (X,A)
    rts

_srand:    sta    rand+0        ; Store the seed
    stx    rand+1
    lda     #0
    sta     rand+2          ; Set MSW to zero
    sta     rand+3
    rts






;
; Written by Groepaz/Hitmen <groepaz@gmx.net>
; Cleanup by Ullrich von Bassewitz <uz@cc65.org>
;
; void __fastcall__ waitvblank(void);
;

    .export _waitvblank

PPU_STATUS    = $2002    ;.include "nes.inc"

.proc   _waitvblank

wait:   lda     PPU_STATUS
        bpl     wait
        rts

.endproc



*/



