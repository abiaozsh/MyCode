Microsoft (R) Macro Assembler (x64) Version 10.00.40219.01  07/04/17 17:11:34
div.asm							     Page 1 - 1


				;The terms “less” and “greater” are used for comparisons of signed integers
				;the terms “above” and “below” are used for unsigned integers.

				;Intel386函数传参是通过ebp寄存器和栈实现的，而AMD64稍有不同。函数参数是通过寄存器传递的，
				;从第一个参数开始依次为rdi, rsi, rdx, rcx, r8, r9。可以理解为这六个寄存器归被调函数所有。
				;rbp, rbx, r12, r13, r14, r15属于调用函数，如果被调函数要用这六个寄存器，要在栈中进行push/pop操作。
				;如果明白了这一点，再看汇编程序，大部分操作都是在准备rdi, rsi, rdx, rcx, r8, r9这六个寄存器，
				;也就是函数参数。

				;c d 8 9 入参
				; RBX、RBP、RDI、RSI、R12、R13、R14 和 R15 需要保护
				; RAX、RCX、RDX、R8、R9、R10 和 R11 不需保护

				PUBLIC	divcore
 00000000			_TEXT	SEGMENT
				;rcx r, rdx b, r8 idx_main, r9 len
				;PSE$ = 8
 00000000			divcore	PROC
					
 00000000  56				push rsi
 00000001  57				push rdi

 00000002  4C/ 8B DA			mov r11,rdx					;b
 00000005  4A/ 8D 3C C1			lea rdi,[rcx+r8*8]			;mov edi,&r[idx_main]
 00000009  4A/ 8B 14 C1			mov rdx,[rcx+r8*8]			;rh = r[idx_main];
 0000000D  4A/ 8B 44 C1			mov rax,[rcx+r8*8+8]		;rl = r[idx_main + 1];
	   08
 00000012  49/ 8B 0B			mov rcx,[r11]				;mov ecx,b[0];

 00000015  48/ 3B D1			cmp rdx,rcx
 00000018  74 05			jz else1
 0000001A  48/ F7 F1				div rcx
 0000001D  EB 0A				jmp endif1
 0000001F				else1:
 0000001F  48/ C7 C0				mov rax,0
	   00000000
 00000026  48/ F7 D0				not rax
 00000029				endif1:

					;r8:商
 00000029  4C/ 8B C0			mov r8,rax					;mov q,eax

					;乘减 [rdi] = [rsi]*r8 - [rdi];
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;借位
 0000002C  49/ 8D 73 F8			lea rsi,[r11-8]				;mov esi,&b[-1];
 00000030  49/ 8B C9			mov rcx,r9					;mov ecx,len
					
 00000033  49/ C7 C2			mov r10,0					;mov ebx,0 ;rbx => r10
	   00000000
 0000003A				lp1:
 0000003A  49/ 8B C0				mov rax,r8
 0000003D  48/ 99				cqo
 0000003F  48/ F7 24 CE				mul QWORD PTR [rsi+rcx*8]
 00000043  49/ 03 C2				add rax,r10
 00000046  48/ 83 D2 00				adc rdx,0
 0000004A  4C/ 8B D2				mov r10,rdx
 0000004D  48/ 8B D0				mov rdx,rax
 00000050  48/ F7 D2				not rdx
 00000053  48/ 2B 04 CF				sub rax,[rdi+rcx*8]
 00000057  48/ F7 D8				neg rax
 0000005A  48/ 89 04 CF				mov [rdi+rcx*8],rax
 0000005E  48/ 3B D0				cmp rdx,rax
 00000061  49/ 83 D2 00				adc r10,0
 00000065  48/ FF C9			dec rcx
 00000068  75 D0			jnz lp1
 0000006A  4C/ 29 17			sub [rdi],r10
					;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

					;加回
					;0,1,2 times
					;while (r[idx_main]>0x7FFFFFFFFFFFFFFF) (r[idx_main]<0)
 0000006D				jp1:
 0000006D  48/ 8B 07			mov rax,[rdi]
 00000070  48/ 83 F8 00			cmp rax,0
 00000074  7D 24			jge jp2	 ;r[idx_main]<0
 00000076  49/ 8B C9				mov rcx,r9				;mov ecx,len
 00000079  F8					clc
 0000007A					lp2:
 0000007A  48/ 8B 04 CF					mov rax,[rdi+rcx*8]
 0000007E  48/ 13 04 CE					adc rax,[rsi+rcx*8]
 00000082  48/ 89 04 CF					mov [rdi+rcx*8],rax
 00000086  48/ FF C9				dec rcx
 00000089  75 EF				jnz lp2
 0000008B  48/ 8B 07				mov rax,[rdi]
 0000008E  48/ 83 D0 00				adc rax,0
 00000092  48/ 89 07				mov [rdi],rax
 00000095  49/ FF C8				dec r8				;q--;
 00000098  EB D3			jmp jp1
 0000009A				jp2:

 0000009A  5F				pop rdi
 0000009B  5E				pop rsi

 0000009C  49/ 8B C0			mov rax,r8

 0000009F  C3				ret
 000000A0			divcore	ENDP
 000000A0			_TEXT	ENDS


				PUBLIC	divn
 000000A0			_TEXT	SEGMENT
				;rcx Precision, rdx Num_Array, r8 pExponent, r9 n
				;extern "C" void divn(int Precision, unsigned int* Num_Array, int* pExponent, unsigned int n)
				;PSE$ = 8
 000000A0			divn	PROC
 000000A0  53				push rbx
 000000A1  56				push rsi
 000000A2  57				push rdi

 000000A3  4C/ 8B D9			mov r11,rcx
 000000A6  48/ 8B F2			mov rsi,rdx
 000000A9  48/ 8B FA			mov rdi,rdx	;写结果
 000000AC  48/ 8B 06			mov rax,[rsi]
 000000AF  48/ C7 C2			mov rdx,0
	   00000000
 000000B6  49/ F7 F1			div r9
					;mov rdx,rdx 余数变高部(不用做)

 000000B9  48/ 83 F8 00			cmp rax,0
 000000BD  49/ 8B D8			mov rbx,r8
 000000C0  74 0A			jz jp0
						;结果不是0时
 000000C2  48/ 89 07				mov [rdi],rax	;保存结果
 000000C5  48/ 83 C7 08				add rdi,8	;移动指针
 000000C9  48/ FF 03				inc QWORD PTR [rbx]	;抵消(幂-1)
 000000CC				jp0:
					;结果是0时,不保存结果,不移动指针
 000000CC  48/ FF 0B			dec QWORD PTR [rbx]		;幂-1

 000000CF  48/ 83 C6 08			add rsi,8
 000000D3  49/ 8B CB			mov rcx,r11	;Precision
 000000D6  48/ FF C9			dec rcx
 000000D9  48/ 83 F9 00			cmp rcx,0
 000000DD  74 16			jz ext
 000000DF				lp:
 000000DF  48/ 8B 06				mov rax,[rsi]
 000000E2  49/ F7 F1				div r9
 000000E5  48/ 89 07				mov [rdi],rax
 000000E8  48/ 83 C6 08				add rsi,8
 000000EC  48/ 83 C7 08				add rdi,8
 000000F0  48/ FF C9			dec rcx
 000000F3  75 EA			jnz lp
 000000F5				ext:

 000000F5  5F				pop rdi
 000000F6  5E				pop rsi
 000000F7  5B				pop rbx
 000000F8  C3				ret
 000000F9			divn	ENDP
 000000F9			_TEXT	ENDS

				END
Microsoft (R) Macro Assembler (x64) Version 10.00.40219.01  07/04/17 17:11:34
div.asm							     Symbols 2 - 1




Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

divcore  . . . . . . . . . . . .	P 	 00000000 _TEXT	Length= 000000A0 Public
  else1  . . . . . . . . . . . .	L 	 0000001F _TEXT	
  endif1 . . . . . . . . . . . .	L 	 00000029 _TEXT	
  lp1  . . . . . . . . . . . . .	L 	 0000003A _TEXT	
  jp1  . . . . . . . . . . . . .	L 	 0000006D _TEXT	
  lp2  . . . . . . . . . . . . .	L 	 0000007A _TEXT	
  jp2  . . . . . . . . . . . . .	L 	 0000009A _TEXT	
divn . . . . . . . . . . . . . .	P 	 000000A0 _TEXT	Length= 00000059 Public
  jp0  . . . . . . . . . . . . .	L 	 000000CC _TEXT	
  lp . . . . . . . . . . . . . .	L 	 000000DF _TEXT	
  ext  . . . . . . . . . . . . .	L 	 000000F5 _TEXT	


Symbols:

                N a m e                 Type     Value    Attr


	   0 Warnings
	   0 Errors
